syntax = "proto2";

package e2e_noa.planning;
  

import "halfplane.proto";
import "affine_transformation.proto";
import "crosswalk_state.proto";
import "piecewise_linear_function.proto";
import "prediction_common.proto";

message SourceProto {
  message TrafficLight {
    optional string id = 1;
    optional string lane_id = 2;
  }
  message Crosswalk {
    optional string crosswalk_id = 1;
    repeated string object_id = 2;
  }
  message NoBlock {
    optional string id = 1;
  }
  message SpeedBump {
    optional string id = 1;
  }
  message EndOfPathBoundary {
    optional string id = 1;
  }
  message Intersection {
    optional string id = 1;
  }
  message CloseObject {
    optional string id = 1;
  }
  message EndOfCurrentLanePath {
    optional string id = 1;
  }
  message RouteDestination {
    optional string id = 1;
  }
  message LcEndOfCurrentLane {
    optional string id = 1;
  }
  message ParkingBrakeRelease {
    optional string id = 1;
  }
  message BlockingStaticObject {
    optional string id = 1;
  }
  message Pedestrian {
    optional string id = 1;
  }
  message Toll {
    optional string id = 1;
  }
  // Note: Standby just used for visualization currently, if used as
  // decision in the future, delete this comment.
  message Standby {
    optional string reason = 1;
  }
  message Standstill {
    optional string reason = 1;
  }
  message PullOver {
    optional string reason = 1;
  }
  message BrakeToStop {
    optional string reason = 1;
  }
  // Freespace planning.constraint.
  message EndOfLocalPath {
    optional string reason = 1;
  }
  message BeyondLengthAlongRoute {
    optional string id = 1;
  }
  message SolidLineWithinBoundary {
    optional string id = 1;
  }
  message OccludedObject {
    optional string id = 1;
  }
  message DenseTrafficFlow {
    optional string id = 1;
  }
  message StopPolyline {
    optional string id = 1;
  }
  oneof type {
    TrafficLight traffic_light = 1;
    Crosswalk crosswalk = 2;
    NoBlock no_block = 3;
    SpeedBump speed_bump = 4;
    EndOfPathBoundary end_of_path_boundary = 5;
    Intersection intersection = 6;
    CloseObject close_object = 7;
    EndOfCurrentLanePath end_of_current_lane_path = 8;
    RouteDestination route_destination = 25;
    LcEndOfCurrentLane lc_end_of_current_lane = 9;
    ParkingBrakeRelease parking_brake_release = 10;
    BlockingStaticObject blocking_static_object = 11;
    Pedestrian pedestrian_object = 12;
    Standby standby = 13;
    Toll toll = 14;
    Standstill standstill = 16;
    PullOver pull_over = 17;
    EndOfLocalPath end_of_local_path = 18;
    BeyondLengthAlongRoute beyond_length_along_route = 19;
    BrakeToStop brake_to_stop = 20;
    SolidLineWithinBoundary solid_line_within_boundary = 22;
    OccludedObject occluded_object = 23;
    DenseTrafficFlow dense_traffic_flow = 24;
    StopPolyline stop_polyline = 26;

    // Next id: 27.
  };
  reserved 15, 21;
}

message ConstraintProto {
  message AvoidLineProto {
    repeated Vec2dProto xy_points = 1;
    message SLPoint {
      optional double s = 1;
      optional double l = 2;
    }
    repeated SLPoint sl_points = 2;
    optional SourceProto source = 3;
    optional string id = 4;
  }

  message StopLineProto {
    optional HalfPlaneProto half_plane = 1;
    // Accumulated s on drive passage.
    optional double s = 2;
    // Expect AV to keep a distance from stop line.
    optional double standoff = 3;
    // Time remaining to active stop line.
    optional double time = 4;
    // Id of constraint.
    optional string id = 5;
    // Constraint source.
    optional SourceProto source = 6;
    optional bool is_extended = 7;
    optional bool is_traffic_light = 8;
  }

  message SpeedRegionProto {
    optional Vec2dProto start_point = 1;
    optional Vec2dProto end_point = 2;
    // Accumulated s on drive passage.
    optional double start_s = 3;
    // Accumulated s on drive passage.
    optional double end_s = 4;
    optional double max_speed = 5;
    optional double min_speed = 6;
    optional string id = 7;
    optional SourceProto source = 8;
  }

  message PathStopLineProto {
    optional HalfPlaneProto half_plane = 1;
    // Accumulated s on path for rac point.
    optional double s = 2;
    // Expect AV to keep a distance from stop line.
    optional double standoff = 3;
    // Time remaining to active stop line.
    optional double time = 4;
    // Id of constraint.
    optional string id = 5;
    // Constraint source.
    optional SourceProto source = 6;
  }

  message PathSpeedRegionProto {
    optional Vec2dProto start_point = 1;
    optional Vec2dProto end_point = 2;
    // Accumulated s on path.
    optional double start_s = 3;
    // Accumulated s on path.
    optional double end_s = 4;
    optional double max_speed = 5;
    optional double min_speed = 6;
    optional string id = 7;
    optional SourceProto source = 8;
  }

  message LeadingObjectProto {
    enum Reason {
      BORROW_BOUNDARY = 1;
      LANE_CHANGE_TARGET = 2;
      BLOCKING_STATIC = 3;
      TRAFFIC_WAITING = 4;
      INTERSECTION = 5;
      UNABLE_TO_OVERTAKE = 6;
      AFTER_STOPLINE = 7;
    }
    optional string traj_id = 1;
    optional Reason reason = 2;
    optional bool is_group_tail = 5;
    message STConstraint {
      optional double t = 1;
      optional double s = 2;
    }
    repeated STConstraint st_constraints = 3;
    repeated PredictedTrajectoryPointProto modified_trajectory = 4;
  }

  message SpeedProfileProto {
    optional SourceProto source = 1;
    optional PiecewiseLinearFunctionDoubleProto vt_upper_constraint = 2;
  }

  message TrafficGapProto {
    optional string leader_id = 1;
    optional string follower_id = 2;
  }

  repeated StopLineProto stop_line = 1;
  repeated SpeedRegionProto speed_region = 2;
  repeated PathStopLineProto path_stop_line = 5;
  repeated PathSpeedRegionProto path_speed_region = 6;
  repeated AvoidLineProto avoid_line = 7;
  repeated SpeedProfileProto speed_profile = 8;

  optional TrafficGapProto traffic_gap = 9;

  reserved 3, 4;
  // Next id: 9.
}

message FsdTrafficLightDeciderStateProto{
  optional sfixed64 last_light_status = 1;
  optional sfixed64 valid_light_status = 2;
  optional sfixed64 light_stop_reason = 3;
  optional double dist_to_junction = 4;
  optional double green_to_yellow_time = 5;
  optional bool green_to_yellow = 6;
  optional bool pass_junction = 7;
  optional bool set_leftwait = 8;
  optional sfixed64 light_counter = 9;
  optional double change_to_unknown_time = 10;
  optional bool unknown_check = 11;
  optional bool fail_detect_enter_leftwait = 12;

  message FsdMultiTrafficLightDeciderStateProto{
    optional sfixed64 last_light_status = 1;
    optional sfixed64 current_light_status = 2;
    optional sfixed64 light_stop_reason = 3;
    optional double green_to_yellow_time = 4;
    optional bool green_to_yellow = 5;
    optional double stop_s = 6;
  }

  repeated FsdMultiTrafficLightDeciderStateProto multi_junc_tl_info = 13;
  optional sfixed64 tl_stop_interface = 14;
  optional bool override_passable = 15;
  optional int32 override_count = 16[default = 0];
  optional int32 block_light_count = 17[default = 0];
  optional int32 none_count = 18[default = 0];
  optional bool normal_override_passable = 19;
  optional string light_id = 20;
  optional string junction_lane_id = 21;
}

message TrafficLightDeciderStateProto {
  optional bool last_tl_proceed = 1;
  optional bool entry_with_left_light_not_red = 2;
  optional bool has_received_known_traffic_light = 3;
  optional string last_tl_decision_lane_id = 4;
  optional FsdTrafficLightDeciderStateProto fsd_tld_state = 5;
}

message StopPolylineDeciderStateProto {
  optional Vec2dProto passable_stop_point = 1;
}

message DeciderStateProto {
  optional TrafficLightDeciderStateProto traffic_light_decision_state = 1;
  repeated e2e_noa.planning.CrosswalkStateProto crosswalk_state = 3;
  optional StopPolylineDeciderStateProto stop_polyline_state = 4;
  reserved 2;
}
